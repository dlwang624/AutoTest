package org.czy.controller;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.ibatis.annotations.Param;
import org.apache.log4j.Logger;
import org.czy.entity.Project;
import org.czy.entity.Qcdb;
import org.czy.service.TestService;
import org.czy.util.Final;
import org.czy.util.Ftp;
import org.czy.util.GetFolderFileNames;
import org.czy.util.GetFtpData;
import org.czy.util.PrintWriter;
import org.json.JSONObject;
import org.junit.internal.runners.statements.Fail;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.multipart.commons.CommonsMultipartFile;
import org.springframework.web.servlet.ModelAndView;

@Controller
@RequestMapping("/file")
@Scope("prototype")
public class FileController {

	private final static Logger LOG = Logger.getLogger(FileController.class);
	
	@Autowired
	private HttpServletRequest request;
	
	@Autowired
	private TestService testService;
	
	
	@RequestMapping(value="/page.htm", method = RequestMethod.GET)
	public ModelAndView uploadPage(HttpServletRequest req) {
		ModelAndView model = new ModelAndView();
		Qcdb db = (Qcdb)req.getSession().getAttribute("QCDB");
		List<Project> prolist = testService.getProById(db);
		model.getModelMap().put("prolist",prolist);
		model.setViewName("upload/showupload");
		return model;
	}
	
	/***
	 * 上传文件 用@RequestParam注解来指定表单上的file为MultipartFile
	 * 
	 * @param file
	 * @return
	 */
	@RequestMapping(value="/fileUpload.htm", method = RequestMethod.POST)
	public ModelAndView fileUpload(@RequestParam("file") MultipartFile file,String testID,HttpServletRequest req) {
		boolean flag = saveFile(file,testID);
		ModelAndView model = new ModelAndView();
		Qcdb db = (Qcdb)req.getSession().getAttribute("QCDB");
		List<Project> prolist = testService.getProById(db);
		model.getModelMap().put("prolist",prolist);
		model.getModelMap().put("msg",flag?"上传成功":"上传失败");
		model.setViewName("upload/showupload");
		return model;
	}

	/***
	 * 读取上传文件中得所有文件并返回
	 * 
	 * @return
	 */
	@RequestMapping(value="/list.htm", method = RequestMethod.GET)
	public ModelAndView list(String testID) {
		String filePath = request.getSession().getServletContext().getRealPath("/") + "fileUpload/data/"+testID+"/";
		ModelAndView mav = new ModelAndView("list");
		File uploadDest = new File(filePath);
		String[] fileNames = uploadDest.list();
		for (int i = 0; i < fileNames.length; i++) {
			//打印出文件名
			LOG.info("文件名"+fileNames[i]);
		}
		return mav;
	}
	
	/***
	 * 保存文件
	 * @param file
	 * @return
	 */
	private boolean saveFile(MultipartFile file,String testID) {
		// 判断文件是否为空
		if (!file.isEmpty()) {
			try {
				// 文件保存路径
				String filePath = request.getSession().getServletContext().getRealPath("/") + "fileUpload/data/"+testID+"/";
				File f = new File(filePath);
				if(!f.exists()){
					f.mkdirs();
				}
				filePath += file.getOriginalFilename();
				// 转存文件
				file.transferTo(new File(filePath));
				return true;
			} catch (Exception e) {
				LOG.info(e);
			}
		}
		return false;
	}
	
	
	@RequestMapping(value="/filesUpload.htm", method = RequestMethod.POST)
	public ModelAndView filesUpload(@RequestParam("files") MultipartFile[] files,String testID,HttpServletRequest req) {
		boolean flag = true;
		//判断file数组不能为空并且长度大于0
		if(files!=null&&files.length>0){
			//循环获取file数组中得文件
			for(int i = 0;i<files.length;i++){
				MultipartFile file = files[i];
				//保存文件
				if(!saveFile(file,testID)){
					flag = false;
				}
			}
		}
		ModelAndView model = new ModelAndView();
		Qcdb db = (Qcdb)req.getSession().getAttribute("QCDB");
		List<Project> prolist = testService.getProById(db);
		model.getModelMap().put("prolist",prolist);
		model.getModelMap().put("msg",flag?"上传成功":"上传失败");
		model.setViewName("upload/showupload");
		return model;
	}
	
	@RequestMapping(value="/download.htm", method = RequestMethod.GET)
	public ResponseEntity<byte[]> download(String fileName,int id,HttpServletRequest req) throws IOException {
		String path = req.getSession().getServletContext().getRealPath("/") + "fileUpload/data/"+id+"/";
		path += fileName;
		File file = new File(path);
        String dfileName = new String(fileName.getBytes("UTF-8"), "iso-8859-1");
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.setContentDispositionFormData("attachment", dfileName);
        return new ResponseEntity<byte[]>(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);
    }
	
	
	/***
	 * 保存文件
	 * @param file
	 * @return
	 */
	private boolean saveFileToFtp(MultipartFile file,FTPClient client) {
		boolean flag = false;
		// 判断文件是否为空
		if (!file.isEmpty()) {
			try {
				// 文件保存路径
				flag = GetFtpData.upload(file,client);
			} catch (Exception e) {
				LOG.info(e);
				flag = false;
			}
		}
		return flag;
	}
	
	/**
	 * 使用ftp上传文件到服务器
	 * @param files
	 * @param testID
	 * @param req
	 * @return
	 */
	@RequestMapping(value="/filesUploadftp.htm", method = RequestMethod.POST)
	public ModelAndView filesUploadFTP(@RequestParam("files")MultipartFile[] files,String testID,HttpServletRequest req) {
		boolean flag = true;
		Ftp f = new Ftp();
		FTPClient ftp = f.connect(Final.FTP_IP, Final.FTP_USERNAME, Final.FTP_PASSWORD);
		try {
			String path = Final.FTP_BASEPATH+testID;
			if (!ftp.changeWorkingDirectory(Final.FTP_BASEPATH)) { 
				String msg = ftp.makeDirectory(Final.FTP_BASEPATH)?"创建成功":"创建失败";
				LOG.info(Final.FTP_BASEPATH+"文件夹"+msg);
			}
			if (!ftp.changeWorkingDirectory(path)) {  
				String msg = ftp.makeDirectory(path)?"创建成功":"创建失败";
				LOG.info(path+"文件夹"+msg);
            }
			if(ftp.changeWorkingDirectory(path)){
				LOG.info("FTP["+path+"]目录存在");
			}else{
				LOG.info("FTP["+path+"]目录不存在");
			}
		} catch (IOException e) {
			LOG.error(e);
			flag = false;
		}
		
		//筛选名字
//		CommonsMultipartFile multipartFile = null;
//        Iterator<String> itr =  fileReq.getFileNames();
//        while(itr.hasNext()){
//            String str = itr.next();
//            multipartFile = (CommonsMultipartFile)fileReq.getFile(str);
//            String fileName = multipartFile.getOriginalFilename();   //原文件名
//            MultipartFile file = fileReq.getFile(str);
//            if(fileName.indexOf(Final.XLS)>0||fileName.indexOf(Final.XLSX)>0){
//				if(!saveFileToFtp(file,ftp)){
//					flag = false;
//				}
//			}
//        }
		
		//判断file数组不能为空并且长度大于0
		if(files!=null&&files.length>0){
			//循环获取file数组中得文件
			for (MultipartFile file : files) {
				if(!saveFileToFtp(file,ftp)){
					flag = false;
				}
			}
		}
		f.closed();
		ModelAndView model = new ModelAndView();
		Qcdb db = (Qcdb)req.getSession().getAttribute("QCDB");
		List<Project> prolist = testService.getProById(db);
		model.getModelMap().put("prolist",prolist);
		model.getModelMap().put("msg",flag?"上传成功":"上传失败");
		model.setViewName("upload/showupload");
		return model;
	}
	
	
	/***
	 * 读取上传文件中得所有文件并返回
	 * 
	 * @return
	 */
	@RequestMapping(value="/folderNames.htm", method = RequestMethod.GET)
	public String folderNames(String id,HttpServletResponse res) {
		JSONObject jsonobj = new JSONObject();
		List<String> list = new ArrayList<String>();
		list = GetFtpData.getFilesName(id);
		List<Map<String, String>> json = new ArrayList<Map<String, String>>();
		if(null!=list){
			for (String filename : list) {
				Map<String, String> map = new HashMap<String, String>();
				map.put("filename", filename);
				json.add(map);
			}
		}
		jsonobj.put("list",json);
		new PrintWriter().ajaxResponse(res, jsonobj);
		LOG.info(id+"文件夹下文件:"+list);
		return "upload/showupload";
	}
	
	@RequestMapping(value="/getFile.htm", method = RequestMethod.GET)
	public ResponseEntity<byte[]> getFile(String fileName,String id,HttpServletRequest req) throws IOException {
		Ftp f = new Ftp();
		FTPClient ftp = f.connect(Final.FTP_IP, Final.FTP_USERNAME, Final.FTP_PASSWORD);
		File file = GetFtpData.downloadExcel(fileName, id, ftp);
        String dfileName = new String(fileName.getBytes("UTF-8"), "iso-8859-1");
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.setContentDispositionFormData("attachment", dfileName);
        f.closed();
    	return new ResponseEntity<byte[]>(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);
    }
	
	@RequestMapping(value="/delFile.htm", method = RequestMethod.POST)
	public void delFile(String fileName,String id,HttpServletResponse res) throws IOException {
		JSONObject jsonobj = new JSONObject();
		Ftp f = new Ftp();
		FTPClient ftp = f.connect(Final.FTP_IP, Final.FTP_USERNAME, Final.FTP_PASSWORD);
		boolean flag = GetFtpData.removeFile(fileName, id, ftp);
        f.closed();
        jsonobj.put("flag",flag);
		new PrintWriter().ajaxResponse(res, jsonobj);
		LOG.info(id+"文件夹删除文件["+fileName+"]:"+flag);
    }
	
	@RequestMapping(value="/showdata.htm", method = RequestMethod.POST)
	public void showdata(String filename,String testID,HttpServletResponse res) throws IOException {
		JSONObject jsonobj = new JSONObject();
		Ftp f = new Ftp();
		FTPClient ftp = f.connect(Final.FTP_IP, Final.FTP_USERNAME, Final.FTP_PASSWORD);
		List<List<Map<String, String>>> list = GetFtpData.showExcelData(filename, testID, ftp);
        f.closed();
        jsonobj.put("sheet",list);
		new PrintWriter().ajaxResponse(res, jsonobj);
		LOG.info("显示"+testID+"文件夹下["+filename+"]文件数据:"+list);
    }
	
}
